import cv


def grayscale(img):
    """ Returns a new grayscale image from a colour one.
    """
    grayscale = cv.CreateImage(cv.GetSize(img), 8, 1)
    cv.CvtColor(img, grayscale, cv.CV_BGR2GRAY)
    return grayscale


def normalise(img):
    """ Returns a normalised copy of a grayscale image
    """
    normalised = cv.CreateImage(cv.GetSize(img), 8, 1)
    cv.EqualizeHist(img, normalised)
    return normalised


def add_dot(img, row, col, colour=(0, 0, 0), diam=5):
    """ Adds a filled circle *in-place* on an image a row, col.
    """
    cv.Circle(img, (col, row), diam, colour, -1)


def add_line(img, row1, col1, row2, col2, colour=(0, 0, 0),  width=2):
    """ Adds a line *in-place* on an image.
    """
    cv.Line(img, (col1, row1), (col2, row2), colour, width)


def add_text(img, x, y, string, colour=(255, 255, 255), size=0.5):
    """ Adds text in-place.
    """
    font = cv.InitFont(cv.CV_FONT_HERSHEY_SIMPLEX, size, size)
    cv.PutText(img, string, (x, y), font, colour)


def get_vert_edges(img, cuts=20, stepsize=5, threshold=100):
    """ Finds vertical edges in an image.

        img is a cv image from cv.LoadImage

        Returns a list of tuples. Each tuple contains an y coordinate (the
        row in the image) and a tuple of x coordinates (edges on the row).
    """
    edges = []
    end = img.height
    step = end / cuts
    start = step / 2
    for row in range(start, end, step):
        rowedges = []
        lastval = None
        for col in range(0, img.width, stepsize):
            val = img[row, col]
            if lastval is not None and abs(val - lastval) > threshold:
                rowedges.append(col - (stepsize / 2))
            lastval = val
        edges.append((row, rowedges))
    return edges


def calc_spaces(numbers):
    """ Returns the difference between each number in a list and the next one.
        Assumes the numbers increase as they go along - eg: [1, 34, 159 ...]

        Returns a list of numbers one shorter that the input list's length.
    """
    return [numbers[i + 1] - numbers[i] for i in range(len(numbers) - 1)]


def calc_edge_spacing(vert_edges):
    """ Uses calc_spaces() to find the distance between the points in some edge
        data generated by get_vert_edges()

        Returns a list of lists of numbers.
    """
    return [calc_spaces(edges) for row, edges in vert_edges]


def get_index_of_near(needle, haystack, proximity):
    """ Searches haystack (a list of numbers) for numbers within proximity to
        needle. Returns index in haystack, or -1.
    """
    for index, hay in enumerate(haystack):
        if abs(hay - needle) <= proximity:
            return index
    return -1


def get_common_spacing(l_edges, l_spacing, r_edges, r_spacing, prox=5):
    """ Compares two sets of edge spacing, looking for common spacings on each
        row. "Common" is based on being within prox distance of each other.

        Returns a list of tuples. Each tuple contains:
         * y coordinate of row
         * (x1, x2) on left image
         * (x1, x2) on right image
    """
    results = []
    for row_i, l_edge in enumerate(l_edges):
        for l_space_i, l_space in enumerate(l_spacing[row_i]):
            r_space_i = get_index_of_near(l_space, r_spacing[row_i], prox)
            if r_space_i == -1:
                continue
            results.append((l_edge[0],
                            (l_edge[1][l_space_i],
                             l_edge[1][l_space_i + 1]),
                            (r_edges[row_i][1][r_space_i],
                             r_edges[row_i][1][r_space_i + 1])))
    return results


def get_depths(common_spacing_data):
    """ Using spacing data from get_common_spacing(), show depth of each
        spacing. Is purely linear, not based on lense etc.
    """
    return [abs(((lx1 + lx2) / 2) - ((rx1 + rx2) / 2))
            for y, (lx1, lx2), (rx1, rx2)
            in common_spacing_data]


def filter_spacing_by_depth(spacing, depths, threshold):
    """ Filters get_common_spacing() data by get_depths() data.
    """
    return [spacing
            for i, spacing
            in enumerate(spacing)
            if depths[i] < threshold]
